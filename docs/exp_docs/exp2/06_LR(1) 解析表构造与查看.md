# 06_LR(1) 解析表构造与查看（Action/Goto）

## 数据结构总览

对象或变量名称 | 数据结构 | 存储结构用途
- | - | -
LR1ActionTable.action | QMap<int, QMap<QString, QString>> | 解析表动作（state×终结符→`sN`/`rK`/`acc`/文本）
LR1ActionTable.gotoTable | QMap<int, QMap<QString, int>> | 解析表转移（state×非终结符→目标状态）
LR1ActionTable.reductions | QVector<QPair<int, QString>> | 规约列表（编号→文本 `k: A -> α`）
computeReductionIndex | 函数 | 生成“文本键→编号”的索引映射
putAction | 函数 | 写入动作，冲突并列为 `prev|val`
redIndex | QMap<QString,int> | 文本键（`A->α`）到规约编号映射
st/a/to | int/QString/int | 状态、符号与目标状态（构表临时变量）

## 算法实现过程
1. 规约编号：遍历文法产生式，按顺序为每个 `A→α` 分配唯一编号，并生成“编号→文本”的列表。
2. 填充移进：对每个状态项，若点后符号为终结符 `X` 且存在 `X` 的迁移边，则写入 `action[state][X] = s{to}`。
3. 填充规约与接受：对完成项（点在末尾）：
   - 若为增广产生式且前瞻为 `$`，写入 `action[state]['$'] = acc`
   - 否则按规约编号优先写入 `rK`；若缺编号则使用文本形式 `r A -> α`
4. 填充 GOTO：对非终结符迁移写入 `goto[state][A] = to`
5. 冲突并列：当某表项已存在不同动作时，合并为 `prev|val`，保留供解析阶段由策略处理。

### 扩展要点（细节说明）
- 规约编号一致性：编号按文法顺序生成，便于解析时以 `rK` 快速定位对应产生式文本；导出时附带列表以供查看。
- 接受项判定：仅当左部为增广开始符且前瞻为 `$` 时写入 `acc`；避免误标普通完成项为接受。
- 合并策略：`prev|val` 合并仅用于展示与后续策略选择，不在构表阶段做自动裁决；解析器根据偏好（移进/规约/指定 token）进行选择。
- 表格一致性：输出时按状态与符号排序，便于对比与诊断；同时统计接受/移进/规约条目数以评估表规模与冲突率。

## 算法实现流程图
<!--【流程图】此处需要添加 “LR(1) 解析表构造流程图”：规约编号→填充移进→填充规约/接受→填充 GOTO→并列冲突。-->

## 关键代码（可选）
```
// 解析表构造（项目源码节选，已格式化）
static void
putAction(QMap<int, QMap<QString, QString>>& action,
          int st,
          const QString& a,
          const QString& val)
{
    QString prev = action[st].value(a);
    if (!prev.isEmpty() && prev != val)
        action[st][a] = prev + "|" + val;
    else
        action[st][a] = val;
}

LR1ActionTable LR1Builder::computeActionTable(const Grammar& g, const LR1Graph& gr)
{
    LR1ActionTable t;
    auto redIndex = computeReductionIndex(g, t.reductions);

    for (int i = 0; i < gr.states.size(); ++i)
    {
        const auto& I = gr.states[i];
        for (const auto& it : I)
        {
            if (it.dot < it.right.size())
            {
                QString X = it.right[it.dot];
                if (isTerminal(g.terminals, X))
                {
                    auto edIt = gr.edges.constFind(i);
                    int  to   = -1;
                    if (edIt != gr.edges.constEnd())
                        to = edIt.value().value(X, -1);
                    if (to >= 0)
                        putAction(t.action, i, X, QString("s%1").arg(to));
                }
            }
            else
            {
                // 接受项
                if (it.left.endsWith(Config::augSuffix()) &&
                    it.lookahead == Config::eofSymbol())
                {
                    putAction(t.action, i, Config::eofSymbol(), "acc");
                }

                // 规约项
                QString a = it.lookahead;
                if (!a.isEmpty() && a != "#")
                {
                    QString key = it.left + "->" + it.right.join(" ");
                    int rk = redIndex.value(key, -1);
                    QString r = (rk >= 0)
                        ? QString("r%1").arg(rk)
                        : QString("r %1 -> %2").arg(it.left).arg(it.right.join(" "));
                    putAction(t.action, i, a, r);
                }
            }
        }

        // GOTO 表
        auto edIt = gr.edges.constFind(i);
        if (edIt != gr.edges.constEnd())
        {
            const auto& edgesMap = edIt.value();
            for (auto eit = edgesMap.begin(); eit != edgesMap.end(); ++eit)
            {
                QString X  = eit.key();
                int     to = eit.value();
                if (!isTerminal(g.terminals, X) && X != "#")
                    t.gotoTable[i][X] = to;
            }
        }
    }

    return t;
}
```

## 单元测试
- 输入：
  - LR(1) 项集 DFA 构造完成；表达式文法（含 `+/*/()/id`）
- 预期结果：
  - `action` 中含多个 `sN` 与 `rK`；接受项位于增广状态的 `$` 前瞻下；`goto` 对 `E/T/F` 给出有效目标。
- 测试结果：
  - 命令行截图：运行解析表构造测试，打印 `action/goto` 表摘要；
  - GUI 截图：在实验二界面点击“查看 LR(1) 解析表”，表格弹窗显示各项。
  - <!--【GUI 截图】此处需要添加 “LR(1) 解析表” 截图：行=状态、列=符号，单元格=动作/转移。-->
