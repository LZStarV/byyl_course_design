# 06_LR(1) 解析表构造与查看（Action/Goto）

## 数据结构总览

对象或变量名称 | 数据结构 | 存储结构用途
| - | - | -
action | 映射 | `state×终结符→动作`，移进/规约/接受
goto | 映射 | `state×非终结符→目标状态` 的转移表
reductions | 列表 | 规约编号到文本映射（`k: A -> α`）
动作字符串 | 字符串 | `sN`、`rK`/`r A -> α`、`acc`
prev/val/to | 变量 | 已有动作、新动作与迁移目标状态

## 算法实现过程
1. 规约编号：遍历文法产生式，按顺序为每个 `A→α` 分配唯一编号，并生成“编号→文本”的列表。
2. 填充移进：对每个状态项，若点后符号为终结符 `X` 且存在 `X` 的迁移边，则写入 `action[state][X] = s{to}`。
3. 填充规约与接受：对完成项（点在末尾）：
   - 若为增广产生式且前瞻为 `$`，写入 `action[state]['$'] = acc`
   - 否则按规约编号优先写入 `rK`；若缺编号则使用文本形式 `r A -> α`
4. 填充 GOTO：对非终结符迁移写入 `goto[state][A] = to`
5. 冲突并列：当某表项已存在不同动作时，合并为 `prev|val`，保留供解析阶段由策略处理。

## 算法实现流程图
<!--【流程图】此处需要添加 “LR(1) 解析表构造流程图”：规约编号→填充移进→填充规约/接受→填充 GOTO→并列冲突。-->

## 关键代码（可选）
```
// 解析表构造（项目源码节选，已格式化）
static void
putAction(QMap<int, QMap<QString, QString>>& action,
          int st,
          const QString& a,
          const QString& val)
{
    QString prev = action[st].value(a);
    if (!prev.isEmpty() && prev != val)
        action[st][a] = prev + "|" + val;
    else
        action[st][a] = val;
}

LR1ActionTable LR1Builder::computeActionTable(const Grammar& g, const LR1Graph& gr)
{
    LR1ActionTable t;
    auto redIndex = computeReductionIndex(g, t.reductions);

    for (int i = 0; i < gr.states.size(); ++i)
    {
        const auto& I = gr.states[i];
        for (const auto& it : I)
        {
            if (it.dot < it.right.size())
            {
                QString X = it.right[it.dot];
                if (isTerminal(g.terminals, X))
                {
                    auto edIt = gr.edges.constFind(i);
                    int  to   = -1;
                    if (edIt != gr.edges.constEnd())
                        to = edIt.value().value(X, -1);
                    if (to >= 0)
                        putAction(t.action, i, X, QString("s%1").arg(to));
                }
            }
            else
            {
                // 接受项
                if (it.left.endsWith(Config::augSuffix()) &&
                    it.lookahead == Config::eofSymbol())
                {
                    putAction(t.action, i, Config::eofSymbol(), "acc");
                }

                // 规约项
                QString a = it.lookahead;
                if (!a.isEmpty() && a != "#")
                {
                    QString key = it.left + "->" + it.right.join(" ");
                    int rk = redIndex.value(key, -1);
                    QString r = (rk >= 0)
                        ? QString("r%1").arg(rk)
                        : QString("r %1 -> %2").arg(it.left).arg(it.right.join(" "));
                    putAction(t.action, i, a, r);
                }
            }
        }

        // GOTO 表
        auto edIt = gr.edges.constFind(i);
        if (edIt != gr.edges.constEnd())
        {
            const auto& edgesMap = edIt.value();
            for (auto eit = edgesMap.begin(); eit != edgesMap.end(); ++eit)
            {
                QString X  = eit.key();
                int     to = eit.value();
                if (!isTerminal(g.terminals, X) && X != "#")
                    t.gotoTable[i][X] = to;
            }
        }
    }

    return t;
}
```

## 单元测试
- 输入：
  - LR(1) 项集 DFA 构造完成；表达式文法（含 `+/*/()/id`）
- 预期结果：
  - `action` 中含多个 `sN` 与 `rK`；接受项位于增广状态的 `$` 前瞻下；`goto` 对 `E/T/F` 给出有效目标。
- 测试结果：
  - 命令行截图：运行解析表构造测试，打印 `action/goto` 表摘要；
  - GUI 截图：在实验二界面点击“查看 LR(1) 解析表”，表格弹窗显示各项。
  - <!--【GUI 截图】此处需要添加 “LR(1) 解析表” 截图：行=状态、列=符号，单元格=动作/转移。-->
