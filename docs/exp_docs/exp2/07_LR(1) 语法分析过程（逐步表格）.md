# 07_LR(1) 语法分析过程（逐步表格）

## 数据结构总览

对象或变量名称 | 数据结构 | 存储结构用途
| - | - | -
ParseStep.step/stack/rest/action/prod | 字段 | 步骤编号、栈内容、剩余输入、动作、产生式文本
ParseResult.steps/root/errorPos | 字段 | 步骤列表、语法树根、错误位置索引
LR1ActionTable.action/gotoTable | 映射 | 解析表（state×终结符→动作；state×非终结符→目标状态）
stack/input/act/step | 变量 | 状态与符号栈、输入序列（含 $）、当前动作、步计数
nodeStk | 栈 | 语法树节点栈（移进/归约构造子树）
policy/preferTokens | 字符串/集合 | 并列动作选择策略与特定 token 偏好集合

## 算法实现过程

- 初始化：栈压入初始状态；在输入序列尾部追加 `$`；步计数清零。
- 读取动作：以栈顶状态与当前前瞻终结符查询 `action` 表得到动作字符串；若包含并列（含 `|`），按策略与偏好挑选其一。
- 移进：当 `act = sN` 时，压栈新状态与终结符；构造语法树叶子节点；记录当前步骤并前进输入。
- 归约：当 `act = rK` 或文本形式 `r A -> α` 时，弹栈 `|α|` 项并收集子树；在 `goto` 表查询 `goto(栈顶状态, A)` 得到新状态并压栈；
   - 记录产生式文本与步骤；语法树中以 `A` 为根、`α` 的子树为孩子。
- 接受：当 `act = acc` 时，记录最终步骤，设置语法树根并终止分析。
- 错误处理：当动作缺失或 `goto` 失败时，记录错误步骤并终止；若上一动作为移进且输入尚有下一符号，可尝试一次“下一前瞻”的重试。

### 扩展要点（细节说明）
- 并列策略：
  - prefer_shift：优先选择移进动作（若存在）；否则选第一候选。
  - prefer_reduce：优先选择规约动作（若存在）；否则选第一候选。
  - 指定 token 偏好：当下一前瞻属于偏好集时，若存在移进候选则选择之，提高特定 token 的可读性。
- 步骤记录：每一步均记录（栈内容、剩余输入、动作文本、产生式文本），便于表格回放与错误定位。
- 归约解析：当动作为 `rK` 时通过编号反查产生式文本；当为 `r A -> α` 时直接解析文本；两者等价，均生成同样的子树结构。
- 错误重试：仅在上一动作为移进时尝试一次；若第二前瞻存在可行动作则替代当前动作；否则按错误终止。
- 终止条件：`acc` 或错误均终止；不进行多轮回退或回溯，保证解析过程确定性。

## 算法实现流程图
<!--【流程图】此处需要添加 “LR(1) 语法分析过程”：初始化→读动作→分支（移进/归约/接受/错误）→记录步骤→循环。-->

## 关键代码（可选）
```
// LR(1) 语法分析主循环（项目源码节选，已格式化）
ParseResult LR1Parser::parse(const QVector<QString>& tokens,
                             const Grammar& g,
                             const LR1ActionTable& t)
{
    ParseResult res;
    QVector<QString> input = tokens;
    input.push_back("$");

    QVector<QPair<int, QString>> stack;
    QVector<ParseTreeNode*>      nodeStk;
    stack.push_back({0, QString()});
    int step = 0;

    while (!input.isEmpty())
    {
        QString a   = input[0];
        int     st  = stack.isEmpty() ? -1 : stack.back().first;
        QString act = t.action.value(st).value(a);

        // 冲突处理
        if (act.contains('|'))
        {
            auto parts  = act.split('|');
            bool hasAcc = false;
            for (auto p : parts)
                if (p == QStringLiteral("acc")) { hasAcc = true; break; }
            if (hasAcc) act = QStringLiteral("acc");
            else
            {
                QString policy = Config::lr1ConflictPolicy().trimmed().toLower();
                auto    prefer = Config::lr1PreferShiftTokens();
                QString nextTok = a;
                // ......（优先移进的选择逻辑）
                if (act.isEmpty())
                {
                    if (policy == "prefer_shift")
                    {
                        QString pick;
                        for (auto p : parts) if (p.startsWith("s")) { pick = p; break; }
                        if (pick.isEmpty()) pick = parts[0];
                        act = pick;
                    }
                    else if (policy == "prefer_reduce")
                    {
                        QString pick;
                        for (auto p : parts) if (p.startsWith("r")) { pick = p; break; }
                        if (pick.isEmpty()) pick = parts[0];
                        act = pick;
                    }
                    else
                    {
                        // 错误：未配置冲突策略
                        break;
                    }
                }
            }
        }

        // 动作缺失与重试
        if (act.isEmpty())
        {
            if (!res.steps.isEmpty() && res.steps.back().action.startsWith("s") && input.size() > 1)
            {
                QString a2   = input[1];
                QString act2 = t.action.value(st).value(a2);
                if (!act2.isEmpty()) act = act2;
            }
            if (act.isEmpty()) break; // 记录错误并终止
        }

        // 接受
        if (act == "acc") break; // 记录接受并终止

        // 移进
        if (act.startsWith("s"))
        {
            int to = act.mid(1).toInt();
            stack.push_back({to, a});
            ParseTreeNode* n = new ParseTreeNode;
            n->symbol        = a;
            nodeStk.push_back(n);
            // 记录步骤
            input.pop_front();
            continue;
        }

        // 归约
        if (act.startsWith("r"))
        {
            QString          L;
            QVector<QString> rhs;
            // ......（解析归约文本或编号）
            int k = rhs.isEmpty() ? 0 : rhs.size();
            QVector<ParseTreeNode*> kids;
            for (int i = 0; i < k; ++i)
            {
                if (!stack.isEmpty()) stack.pop_back();
                if (!nodeStk.isEmpty()) { kids.push_back(nodeStk.back()); nodeStk.pop_back(); }
            }
            std::reverse(kids.begin(), kids.end());
            int stTop = stack.isEmpty() ? -1 : stack.back().first;
            int to    = t.gotoTable.value(stTop).value(L, -1);
            if (to < 0) break; // 记录错误并终止

            stack.push_back({to, L});
            ParseTreeNode* p = new ParseTreeNode;
            p->symbol        = L;
            p->children      = kids;
            nodeStk.push_back(p);
            // 记录步骤
            continue;
        }

        // 未知动作
        break; // 记录错误并终止
    }

    return res;
}
```

## 单元测试
- 输入：
  - Token 序列来源于表达式文法的词法输出（含 `id,(,),+,*` 等）。
- 预期结果：
  - 过程完整抵达 `acc`；步骤表含移进与归约交替记录；错误场景下记录最近一步的错误信息。
- 测试结果：
  - 命令行截图：运行 LR(1) 解析过程测试，打印若干步的 `stack/rest/action/production`；
  - GUI 截图：在实验二界面点击“运行语法分析”后，预览语法树；
  - <!--【表格 截图】此处需要添加 “解析过程步骤表” 截图：每行一个 ParseStep，含栈、剩余输入、动作、产生式。-->
