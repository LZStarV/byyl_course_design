# 08_语法树生成与预览（ParseTree/SemanticAST）

## 数据结构总览

对象或变量名称 | 数据结构 | 存储结构用途
| - | - | -
ParseTreeNode | 结构体 | 语法树节点的符号与孩子列表
SemanticASTNode | 结构体 | 语义树节点的标签与孩子列表
identifierTokenNames | 集合 | 标识符类终结符名称集合（词素增强）
roles/roleMeaning | 映射/列表 | 候选位角色定义与含义（root/child/sibling）
rootPolicy/childOrder | 字符串 | 根选择与孩子附加顺序策略
nodeStk/semStk | 栈 | 语法树/语义树构建过程的节点栈
lexemes | 序列 | 词素序列（与 Token 对齐，可选）

## 算法实现过程
1. 语法树构建（移进）：当移进一个终结符时，创建叶子 `ParseTreeNode` 并入栈；语义栈压入对应的 `SemanticASTNode`（标识符类终结符可直接生成 `token(lexeme)` 标签）。
2. 语法树构建（归约）：当归约 `A→α` 时，弹出 `|α|` 个孩子并逆序恢复；以 `A` 为根建立新节点并将孩子附加；随后查询 `goto` 并压栈状态。
3. 语义树构建：对于归约，按 `roles/roleMeaning` 将某些孩子标记为根/孩子/并列兄弟；
   - 若存在多个根标记：构造聚合节点并并列附加；
   - 若无标记：默认单子树直提升，否则新建根并附加有效孩子；
   - `rootPolicy` 决定根位选择（如“last_1”），`childOrder` 决定孩子附加顺序。
4. 顶层包装：在接受后，将语义树外包一层以开始符命名的节点。
5. 预览与导出：将语法树（或语义树）序列化为 DOT 文本，并使用图形工具渲染或导出。

## 算法实现流程图
<!--【流程图】此处需要添加 “语法树与语义树构建流程图”：移进叶子→归约建子树→角色策略组装→顶层包装→预览/导出。-->

## 关键代码（可选）
```
// 语义树构建（项目源码节选，已格式化）
static SemanticASTNode*
buildSemantic(const QString&                   L,
              const QVector<SemanticASTNode*>& semKids,
              const QVector<int>&              roles,
              const QMap<int, QString>&        roleMeaning,
              const QString&                   rootPolicy,
              const QString&                   childOrder)
{
    QString llow = L.trimmed().toLower();

    // 标识符类提升或打包
    {
        QVector<QString> lowers;
        for (auto s : Config::identifierTokenNames())
            lowers.push_back(s.trimmed().toLower());
        if (lowers.contains(llow))
        {
            if (semKids.size() == 1 && semKids[0])
                return semKids[0];
            auto* root = new SemanticASTNode();
            root->tag  = L;
            for (auto c : semKids) if (c) root->children.push_back(c);
            return root;
        }
    }

    // 无角色标注：默认直提升或聚合
    if (roles.isEmpty())
    {
        if (semKids.size() == 1 && semKids[0])
            return semKids[0];
        auto* root = new SemanticASTNode();
        root->tag  = L;
        for (auto c : semKids) if (c) root->children.push_back(c);
        return root;
    }

    // 多 root：聚合节点
    int rootCount = 0;
    for (int i = 0; i < roles.size(); ++i)
        if (roleMeaning.value(roles[i]) == "root")
            rootCount++;
    if (rootCount > 1)
    {
        auto* root = new SemanticASTNode();
        root->tag  = L;
        QVector<int> idxs;
        for (int i = 0; i < roles.size(); ++i)
        {
            auto m = roleMeaning.value(roles[i]);
            if (m == "root" || m == "child" || m == "sibling")
                idxs.push_back(i);
        }
        for (int i : idxs)
            if (i < semKids.size() && semKids[i])
                root->children.push_back(semKids[i]);
        return root;
    }

    // 单 root：选择与子序策略
    int rootIdx = -1;
    QVector<int> rootIdxs;
    for (int i = 0; i < roles.size(); ++i)
    {
        auto m = roleMeaning.value(roles[i]);
        if (m == "root")
        {
            rootIdxs.push_back(i);
            if (rootIdx < 0) rootIdx = i;
            else if (rootPolicy == "last_1") rootIdx = i;
        }
    }
    QVector<int> childIdx;
    QVector<int> siblingIdx;
    for (int i = 0; i < roles.size(); ++i)
    {
        auto m = roleMeaning.value(roles[i]);
        if (m == "child") childIdx.push_back(i);
        else if (m == "sibling") siblingIdx.push_back(i);
    }

    SemanticASTNode* root = nullptr;
    if (rootIdx >= 0 && rootIdx < semKids.size() && semKids[rootIdx])
        root = semKids[rootIdx];
    else
    {
        root = new SemanticASTNode();
        root->tag = L;
    }

    if (childOrder == "rhs_order")
    {
        for (int idx : childIdx)
            if (idx < semKids.size() && semKids[idx] && idx != rootIdx)
                root->children.push_back(semKids[idx]);
    }
    else
    {
        for (int i = childIdx.size() - 1; i >= 0; --i)
        {
            int idx = childIdx[i];
            if (idx < semKids.size() && semKids[idx] && idx != rootIdx)
                root->children.push_back(semKids[idx]);
        }
    }

    for (int i = 0; i < rootIdxs.size(); ++i)
    {
        int idx = rootIdxs[i];
        if (idx == rootIdx) continue;
        if (idx < semKids.size() && semKids[idx])
            root->children.push_back(semKids[idx]);
    }
    for (int idx : siblingIdx)
    {
        if (idx < semKids.size() && semKids[idx] && idx != rootIdx)
            root->children.push_back(semKids[idx]);
    }
    return root;
}
```

## 单元测试
- 输入：
  - Token 序列与词素序列来自表达式文法的词法输出（`id,(,),+,*` 等）。
- 预期结果：
  - 语法树按归约产生式逐步构建；语义树在标识符与角色标注时形成合适的根与孩子；DOT 渲染得到清晰的树形图。
- 测试结果：
  - 命令行截图：运行语法树/语义树构建测试，导出 DOT 并渲染 PNG；
  - GUI 截图：点击“预览语法树”或“导出 DOT”后弹出预览或保存提示。
  - <!--【GUI 截图】此处需要添加 “语法树 预览图” 截图：Graphviz 渲染 PNG；以及“语义过程日志”片段。-->
