# 01 正则解析与预处理

## 数据结构

表 1 数据结构总览
对象或结构名称 Rule
数据结构类型 结构体
存储结构用途 保存宏或 Token 的名称、表达式、是否为 Token、编码、是否为组（S）

对象或结构名称 RegexFile
数据结构类型 结构体
存储结构用途 统筹保存宏与 Token 规则集合，供后续解析与构造使用

对象或结构名称 TokenHeaderConfig
数据结构类型 结构体
存储结构用途 配置命名头的前缀、名称字符范围、编码数字范围、组后缀及可选性

对象或结构名称 Alphabet
数据结构类型 结构体
存储结构用途 保存符号集合与字母/数字类别等配置，提供有序遍历

## 算法实现过程

- 初始化与配置：
  - 准备空的宏映射与 Token 列表；设置命名头解析配置（前缀、名称字符范围、编码数字范围、组后缀与是否可选）。
- 行读取与分割：
  - 逐行读取规则文本，执行 trim 去除空白；若行为空或不含 '='，跳过；
  - 以第一个 '=' 为界，左侧作为名称（宏或 Token 命名头），右侧作为正则表达式文本，两侧均 trim。
- 命名头解析与校验：
  - 前缀检查（如 '_'）；
  - 组后缀处理（如 'S'，允许可选时命中则 isGroup=true 并剔除后缀进入后续步骤）；
  - 编码数字提取：自右向左扫描允许的数字字符，按十进制累加形成 code；未提取到任何数字则解析失败；
  - 名称主体校验：首字符需在“首字符范围”，其余字符需在“其余字符范围”；不满足则解析失败；
  - 成功则返回 code/isGroup，失败则视为宏。
- 构造规则文件：
  - 命名头解析成功 → 构造 Rule（isToken=true、code、isGroup）并按出现顺序追加到 tokens；
  - 命名头解析失败 → 构造宏规则（isToken=false）并插入到 rules 映射（键为宏名称）。
- 解析与展开：
  - 对 '[]' 字符类进行范围展开（如 'A-Z'、'0-9'），允许空白与分隔符（逗号/分号），支持颠倒区间（'Z-A'）按升序展开；
  - 对 '()' 的嵌套内容进行范围扩展，保留选择与连接结构；转义 '\\' 用于将 '+/*/?/|/()' 视为字面，避免误判为运算符。
- 宏字符集聚合：
  - 从宏表达式中提取字符集合，映射到列位置，用于列聚合与展示；对嵌套括号与转义进行统一处理，聚合为宏集合。
- 连接显式化：
  - 在“普通字符或转义字面后接普通字符或左括号”的情况下插入隐式连接（在解析阶段体现为 Concat），使表达式在后续 AST 构建中结构明确。
- 字母表构建与排序：
  - 收集所有出现的单字符与字符类标签，形成有序符号集并稳定排序（供状态表与生成器使用）。
- 输出与流转：
  - 将宏与 Token 集合封装为 RegexFile 结构，携带 Alphabet 进入后续 AST 构建与自动机构造流程。

下图为“规则文本解析流程图”占位（从输入到宏/Token 集合）：
<!--【流程图】此处需要添加 '规则文本解析流程图'：文本→行处理→命名头→宏/Token 集合。 -->

下图展示“预处理流程图”（从原始文本到字母表构建）：
<!--【流程图】此处需要添加 '预处理流程图'：范围展开/宏聚合/连接显式化/字母表构建。 -->

下图展示“加载正则文件界面图”：
<!--【GUI 截图】此处需要添加 '加载正则文件界面图'：展示打开 .regex 文件与解析统计。 -->

## 关键代码片段

- 构建命名头解析配置并执行解析：
```
static bool parseTokenHeader(const QString& name, int& code, bool& isGroup)
{
    TokenHeaderConfig cfg;
    // 允许的前缀（例如 '_'）
    cfg.prefix                = /* 例如 '_' */;
    // 名称首字符允许范围（例如 A-Z,a-z,_）
    cfg.name_first_ranges     = /* 例如 'A-Z,a-z,_' */;
    // 名称其余字符允许范围（例如 A-Z,a-z,0-9,_）
    cfg.name_rest_ranges      = /* 例如 'A-Z,a-z,0-9,_' */;
    // 编码数字允许范围（例如 0-9）
    cfg.code_digit_ranges     = /* 例如 '0-9' */;
    // 组后缀（例如 'S'），用于表示多备选的起始编码
    cfg.group_suffix          = /* 例如 'S' */;
    // 是否允许组后缀省略（严格/宽松）
    cfg.group_suffix_optional = /* true/false */;
    // 执行命名头解析：输出 code 与 isGroup
    return TokenHeaderParser::parseHeader(name, cfg, code, isGroup);
}
```

- 命名头解析的核心实现（简化版）：
```
bool parseHeader(const QString& s, const TokenHeaderConfig& cfg, int& code, bool& isGroup)
{
    code = 0; isGroup = false;
    // 前缀校验：名称需以指定前缀开始
    if (!cfg.prefix.isEmpty() && !s.startsWith(cfg.prefix)) return false;
    int start = cfg.prefix.size();
    int end = s.size();
    // 处理可选组后缀（例如 'S'）
    if (!cfg.group_suffix.isEmpty() && end > start) {
        if (s[end - 1] == cfg.group_suffix[0]) { isGroup = true; end -= 1; }
        else if (!cfg.group_suffix_optional) { return false; }
    }
    // 从尾部向前提取编码数字（十进制累加）
    auto digitSet = expandRanges(cfg.code_digit_ranges);
    int p = end - 1, pow10 = 1;
    while (p >= start && digitSet.contains(s[p])) {
        int d = s[p].unicode() - '0';
        code += d * pow10; pow10 *= 10; p--;
    }
    if (pow10 == 1) return false; // 未提取到任何数字，解析失败
    // 名称主体字符校验（首字符与其余字符）
    int nameStart = start, nameEnd = p + 1;
    if (nameEnd <= nameStart) return false; // 名称主体为空
    auto firstSet = expandRanges(cfg.name_first_ranges);
    auto restSet  = expandRanges(cfg.name_rest_ranges);
    if (!firstSet.contains(s[nameStart])) return false;
    for (int k = nameStart + 1; k < nameEnd; ++k) if (!restSet.contains(s[k])) return false;
    return true;
}
```

- 规则文本解析为宏与 Token 集合：
```
RegexFile lex(const QString& input)
{
    RegexFile f;
    // 逐行解析规则文本
    auto lines = input.split('\n');
    for (auto line : lines) {
        auto trimmed = line.trimmed();
        // 跳过空行
        if (trimmed.isEmpty()) continue;
        // 查找第一个 '='，分割出名称与表达式
        int eq = trimmed.indexOf('=');
        if (eq < 0) continue;
        // 左侧为名称（宏或命名头），右侧为正则表达式
        QString left  = trimmed.left(eq).trimmed();
        QString right = trimmed.mid(eq + 1).trimmed();
        Rule r; r.name = left; r.expr = right;
        int code = 0; bool isGroup = false;
        // 命名头解析成功 → Token；否则 → 宏
        if (parseTokenHeader(left, code, isGroup)) {
            r.isToken = true; r.code = code; r.isGroup = isGroup;
            f.tokens.push_back(r);
        } else {
            r.isToken = false; f.rules.insert(left, r);
        }
    }
    return f;
}
```

- 范围展开与宏集合提取、列聚合：
```
// 将形如 "A-Z, a-z; 0-9" 的范围表达式展开为具体字符集合
static QSet<QChar> expandRangesLocal(const QString& ranges)
{
    QSet<QChar> set;
    int i = 0, n = ranges.size();
    auto skip = [&]() { while (i < n && (ranges[i] == ' ' || ranges[i] == '\t')) i++; };
    skip();
    while (i < n)
    {
        skip(); if (i >= n) break;
        QChar a = ranges[i++];
        if (i < n && ranges[i] == '-')
        {
            i++;
            if (i < n)
            {
                QChar b = ranges[i++];
                ushort ua = a.unicode(), ub = b.unicode();
                if (ua <= ub) { for (ushort u = ua; u <= ub; ++u) set.insert(QChar(u)); }
                else          { for (ushort u = ub; u <= ua; ++u) set.insert(QChar(u)); }
            }
        }
        else { set.insert(a); }
        skip(); if (i < n && (ranges[i] == ',' || ranges[i] == ';')) i++; skip();
    }
    return set;
}

// 从宏规则中提取字符集合，供列聚合与展示使用
static QMap<QString, QSet<QChar>> macroSetsFromRules(const QMap<QString, Rule>& macros)
{
    QMap<QString, QSet<QChar>> m;
    auto keys = macros.keys();
    for (const auto& k : keys)
    {
        const auto& r = macros.value(k);
        QSet<QChar> set; const QString& expr = r.expr;
        int i = 0, n = expr.size();
        while (i < n)
        {
            while (i < n && (expr[i] == ' ' || expr[i] == '\t' || expr[i] == '\n' || expr[i] == '\r')) i++;
            if (i >= n) break;
            if (expr[i] == '[')
            {
                int j = i + 1; QString ranges;
                while (j < n && expr[j] != ']') { ranges.append(expr[j]); j++; }
                if (j < n && expr[j] == ']') { set.unite(expandRangesLocal(ranges)); i = j + 1; }
                else break;
            }
            else if (expr[i] == '(')
            {
                int j = i + 1, depth = 1; QString inner;
                while (j < n && depth > 0)
                {
                    if (expr[j] == '(') depth++; else if (expr[j] == ')') depth--;
                    if (depth > 0) inner.append(expr[j]); j++;
                }
                set.unite(expandRangesLocal(inner)); i = j;
            }
            else if (expr[i] == '\\')
            {   // 处理转义字面字符
                if (i + 1 < n) { set.insert(expr[i + 1]); i += 2; }
                else break;
            }
            else { set.insert(expr[i]); i++; }
        }
        if (!set.isEmpty()) m.insert(r.name, set);
    }
    return m;
}

// 将单字符列按宏字符集合聚合为宏列，提升表格可读性
static void aggregateTableByMacros(Tables& t,
                                   const QMap<QString, QSet<QChar>>& msets,
                                   const QMap<QString, QString>&     mexpr)
{
    if (msets.isEmpty()) return;
    int colCount = t.columns.size(); if (colCount < 3) return;
    bool hasEps = (colCount > 0 && t.columns.last() == QStringLiteral("#"));
    int symStart = 2, symEnd = hasEps ? (colCount - 1) : colCount;
    // 建立单字符列索引
    QMap<QChar, int> charIdx;
    for (int ci = symStart; ci < symEnd; ++ci) { const QString& c = t.columns[ci]; if (c.size() == 1) charIdx.insert(c[0], ci); }
    // 记录需要移除的单字符列、保留列与宏命中映射
    QSet<int> removeIdx; QVector<QString> newCols; newCols << t.columns[0] << t.columns[1]; QVector<int> keepIdx;
    auto mkeys = msets.keys(); std::sort(mkeys.begin(), mkeys.end()); QMap<QString, QVector<int>> macroHit;
    for (const auto& name : mkeys)
    {
        const auto& set = msets.value(name); QVector<int> idxs;
        for (auto ch : set) if (charIdx.contains(ch)) idxs.push_back(charIdx.value(ch));
        if (!idxs.isEmpty())
        {
            std::sort(idxs.begin(), idxs.end()); macroHit.insert(name, idxs);
            for (int id : idxs) removeIdx.insert(id);
            QString label = name; if (mexpr.contains(name)) label += QStringLiteral(" (") + mexpr.value(name) + QStringLiteral(")");
            newCols.push_back(label);
        }
    }
    for (int ci = symStart; ci < symEnd; ++ci) { if (!removeIdx.contains(ci)) { newCols.push_back(t.columns[ci]); keepIdx.push_back(ci); } }
    if (hasEps) newCols.push_back(QStringLiteral("#"));
    // 合并多个列目标为宏列目标（去重并排序）
    auto mergeTargets = [&](const QStringList& parts)
    {
        QSet<QString> uniq; for (const auto& p : parts) { for (const auto& seg : p.split(',', Qt::SkipEmptyParts)) uniq.insert(seg.trimmed()); }
        QList<QString> v = QList<QString>(uniq.begin(), uniq.end()); std::sort(v.begin(), v.end()); return v.isEmpty() ? QString() : v.join(',');
    };
    QVector<QVector<QString>> newRows;
    for (const auto& row : t.rows)
    {
        QVector<QString> nr; nr << row[0] << row[1];
        for (const auto& name : mkeys)
        {
            if (!macroHit.contains(name)) continue; QStringList parts; for (int id : macroHit.value(name)) parts << row[id]; nr.push_back(mergeTargets(parts));
        }
        for (int id : keepIdx) nr.push_back(row[id]); if (hasEps) nr.push_back(row[symEnd]); newRows.push_back(nr);
    }
    t.columns = newCols; t.rows = newRows;
}
```

## 输入/输出与示例

输入：规则文本（多行字符串，按“名称 = 表达式”的格式组织）。
输出：规则文件结构（RegexFile，包含宏映射与 Token 列表，携带 Alphabet 进入后续流程）。

- `_ID101 = letter (letter | digit)*`
  - 命名头 `_ID101`：前缀 `_`，名称 `ID`，编码 `101`，无组后缀；解析为单一 Token，编码 101。
  - 表达式：以宏 `letter` 与 `digit` 组合的标识符规则；将进入后续 AST 构建与自动机构造流程。

- `_specail200S = \+ | - | \* | / | = | < | <= | <<`
  - 命名头 `_specail200S`：前缀 `_`，名称 `specail`，编码起点 `200`，组后缀 `S`；解析为“多词组”起点编码。
  - 由于表达式包含多个备选，后续构造会将它们分别生成自动机并赋予 `200, 201, 202...` 等连续编码。

## 单元测试

输入：
```
letter = [A-Za-z_]
digit  = [0-9]
_identifier100 = letter(letter|digit)*
_keywords200S  = if | else | read | write | then | end
```

预测结果：
- 解析出非空的 Token 列表；
- Token 名称与编码能够正确关联，`_identifier100` → 100，`_keywords200S` → 200 起始并按备选递增；
- 宏 `letter/digit` 进入宏映射，供后续 AST 构建引用；
- 字母表构建成功且包含相关符号集合。

测试结果：
- CLI 正则流程与解析统计输出正常；
- GUI 截图：加载正则文件界面图、预处理流程图与表格片段截图就近插入。
<!--【GUI 截图】此处需要添加 'CliRegexTest 运行截图'：显示规则解析统计。 -->

